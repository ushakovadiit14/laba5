
ЗАДАЧА 1: Дроби с запоминанием результата


Описание задачи -
Создать систему для работы с математическими дробями, где можно хранить обычные дроби и дроби которые запоминают результат вычислений, чтобы не считать его каждый раз заново.

Логика решения -
Сделали основную дробь которая умеет все базовые операции, и специальную дробь-помощник которая запоминает результат вычисления. Когда результат уже посчитан - просто возвращает его, а когда дробь меняется - забывает старый результат.

Разбор кода -
Основная дробь (SimpleFraction): Хранит числитель и знаменатель, умеет: Вычислять значение (делит числитель на знаменатель), Упрощать дробь (делит числитель и знаменатель на их общий делитель), Проверять что знаменатель не ноль, Автоматически исправлять отрицательный знаменатель

Дробь с запоминанием (CachedFraction): 

Работает через основную дробь, но добавляет: Память для запоминания результата, Когда просят значение - если в памяти есть результат, возвращает его, Если в памяти нет результата - вычисляет и запоминает, Когда меняют числитель или знаменатель - очищает память

Интерфейс дроби (Fraction): 

Определяет что любая дробь должна уметь: Возвращать значение, Устанавливать числитель и знаменатель, Показывать себя как текст

Входные и выходные данные -

Что принимает: Целые числа для числителя и знаменателя. Можно создавать дробь сразу с числами или устанавливать их потом.

Что возвращает: Десятичное значение дроби, текстовое представление в виде "a/b", результаты сравнения дробей.

Особенности работы: Система следит за правильностью дробей - не позволяет создать дробь с нулевым знаменателем, автоматически переносит минус от знаменателя к числителю.




ЗАДАЧА 2: Подсчет мяуканий с помощником-счетчиком


Описание задачи - 
Нужно узнать, сколько раз кот мяукнул во время работы программы, но нельзя менять сам класс кота. Нужно сделать так, чтобы можно было передать кота в любой метод и потом точно узнать количество его мяуканий.

Логика решения - 
Создали специального помощника (CountingCatProxy), который "оборачивает" настоящего кота. Этот помощник выглядит и ведет себя как обычный кот, но дополнительно ведет подсчет всех мяуканий.

Разбор кода -

Базовый кот (Cat): Просто хранит имя и умеет мяукать. При мяукании выводит на экран "Имя: мяу".

Интерфейс мяукания (Meowable): Определяет что любой мяукающий объект должен иметь метод meow().

Помощник-счетчик (CountingCatProxy): Главный элемент системы. Он: Принимает в конструкторе настоящего кота, Имеет внутри счетчик (meowCount)

Когда вызывают его метод meow(), он: Просит настоящего кота мяукнуть, Увеличивает счетчик на 1, Может сообщить текущее количество мяуканий, Может обнулить счетчик

Класс с методами (Funs): Содержит методы которые работают с мяукающими объектами. Они не знают, передали им настоящего кота или помощника-счетчика.

Входные и выходные данные -

Что принимает: Любые объекты которые умеют мяукать (настоящие коты или помощники-счетчики). Можно работать с одним объектом или с целым списком котов.

Что возвращает: Точное количество мяуканий для каждого кота. Помощник-счетчик запоминает все мяукания, даже если они происходили внутри других методов.

Как используется: Создаем настоящего кота, создаем для него помощника-счетчика, передаем помощника в любые методы, а потом спрашиваем у помощника сколько раз мяукнул кот.




ЗАДАЧА 3: Вставка в список после первого вхождения элемента


Описание задачи -
Программа должна находить первый раз когда встречается определенный элемент в списке, и после него вставлять другие элементы. Можно вставлять как весь текущий список, так и произвольные элементы.

Логика решения -
Создан класс-обработчик списка, который умеет находить позицию элемента и вставлять на нужное место другие элементы. Если элемент не найден - вставка не выполняется.

Разбор кода -

Основной класс (ListProcessor): Работает с любыми типами данных через generics (T), Хранит внутренний список элементов, Ищет позицию элемента с помощью indexOf(), Вставляет элементы после найденной позиции с помощью addAll(), Проверяет что элемент существует в списке перед вставкой, Имеет два варианта вставки: всего текущего списка или произвольных элементов

Демонстрационный класс (ListProcessorDemo): Показывает работу программы, Интерактивное меню для пользователя, Возможность добавлять элементы по одному или группой, Автоматические демонстрации разных случаев работы, Поиск элементов в списке

Входные и выходные данные -

Что принимает: Числа для добавления в список, элемент для поиска, элементы для вставки

Что возвращает: Измененный список с вставленными элементами

Как работает: Пользователь создает начальный список -> Выбирает элемент E который нужно найти -> Выбирает что вставить после E (весь список или другие элементы) -> Программа находит первую позицию E и вставляет элементы после нее

Особенности: Если элемент E не найден - вставка не выполняется. Программа сообщает о результате операции.



ЗАДАЧА 4: Обработка данных абитуриентов


Описание задачи -
Нужно прочитать данные о абитуриентах и их баллах по трем предметам, затем найти тех, кто допущен к экзаменам. Для допуска нужно: не менее 30 баллов по каждому предмету и сумма баллов не менее 140.

Логика решения -
Создана система которая читает данные из файла, проверяет каждого абитуриента по условиям допуска и выводит список допущенных. Данные хранятся в структуре Map для быстрого поиска.

Разбор кода -

Класс абитуриента (Applicant): Хранит информацию об одном абитуриенте, Фамилию (до 20 символов) и имя (до 15 символов), Три балла по предметам (от 0 до 100), Проверяет корректность данных при создании, Метод isAdmitted() проверяет условия допуска

Обработчик данных (ApplicantProcessor): Работает со всеми абитуриентами, Читает данные из файла построчно,Разбирает строки на фамилию, имя и баллы, Хранит абитуриентов в Map для избежания дубликатов, Находит всех допущенных абитуриентов, Сортирует допущенных по убыванию суммы баллов

Демонстрационный класс (FileReaderDemo): Показывает работу системы, Создает тестовый файл с данными если его нет, Загружает данные из файла, Показывает всех абитуриентов и их статус, Выводит список допущенных

Входные и выходные данные -

Входные данные: Файл где первая строка - количество абитуриентов, остальные строки - данные в формате "Фамилия Имя балл1 балл2 балл3"

Выходные данные: Список фамилий и имен допущенных абитуриентов

Обработка ошибок: Программа проверяет формат данных, диапазоны баллов, длину имен и фамилий. Сообщает об ошибках в данных но продолжает работу.

Условия допуска: Каждый предмет ≥30 баллов И сумма всех ≥140 баллов




ЗАДАЧА 5: Анализ русских букв в тексте


Описание задачи -
Нужно прочитать текст на русском языке и определить сколько букв русского алфавита ни разу не встречается в этом тексте.

Логика решения -
Созданы два множества (Set): одно содержит все буквы русского алфавита, другое - буквы которые встретились в тексте. Разница между этими множествами показывает отсутствующие буквы.

Разбор кода -

Класс анализатора (TextAnalyzer): Выполняет основную работу, Хранит множество букв которые есть в тексте, Хранит множество букв которых нет в тексте, Читает файл и извлекает все русские буквы, Приводит все буквы к нижнему регистру для единообразия, Сравнивает буквы из текста с полным алфавитом, Находит разницу между алфавитом и буквами из текста

Демонстрационный класс (TextAnalyzerDemo): Показывает работу программы, Меню для выбора действий, Загрузка текста из файла, Показывает только отсутствующие буквы, Показывает полную статистику по всем буквам, 

Входные и выходные данные -

Входные данные: Текстовый файл с русским текстом

Выходные данные: Количество отсутствующих букв и список этих букв 

Как работает: Программа читает текст из файла -> Собирает все уникальные русские буквы которые встретились -> Сравнивает с полным русским алфавитом (33 буквы) -> Находит буквы которых нет в тексте

Особенности: Учитывает букву "ё" как отдельную букву. Все буквы приводятся к нижнему регистру чтобы не различать заглавные и строчные.


ЗАДАЧА 6: Построение очереди из списка


Описание задачи -
Нужно взять список элементов и построить из него очередь, которая содержит сначала все элементы списка в прямом порядке, а затем те же элементы в обратном порядке. Например: из списка [1, 2, 3] получить очередь [1, 2, 3, 3, 2, 1].

Логика решения -
Создается очередь, в которую сначала добавляются все элементы списка в исходном порядке, затем добавляются те же элементы но в обратном порядке, начиная с последнего элемента.

Разбор кода -

Основной класс (Queues): Содержит логику построения очереди, Метод buildQueue принимает список любых элементов, Сначала создает очередь и добавляет все элементы списка в прямом порядке, Затем в цикле проходит список с конца к началу и добавляет каждый элемент в очередь

В результате очередь содержит: оригинальные элементы + элементы в обратном порядке

Демонстрационный класс (QueueDemo): Показывает работу с разными типами данных, Работает с числами, строками и символами, Показывает примеры для стандартных случаев, Поддерживает пользовательский ввод произвольных элементов, Выводит исходный список и результирующую очередь

Входные и выходные данные -

Входные данные: Список элементов любого типа (числа, строки, символы)

Выходные данные: Очередь элементов где сначала идут элементы в прямом порядке, затем те же элементы в обратном порядке

Как работает: Берем список [A, B, C] -> Создаем очередь и добавляем: A, B, C (прямой порядок) -> Затем добавляем: C, B, A (обратный порядок) -> Получаем очередь: A, B, C, C, B, A

Особенности: Программа работает с любыми типами данных благодаря использованию дженериков. Показывает результат сразу после построения очереди.




ЗАДАЧА 7: Обработка точек с помощью Stream API

Описание задачи-
Нужно взять набор точек, убрать дубликаты, отсортировать их по координате X, сделать все координаты Y положительными и собрать результат в ломаную линию.

Логика решения-
Используется цепочка операций Stream API для последовательной обработки точек: удаление дубликатов, сортировка, преобразование координат и сбор в конечный объект.

Разбор кода

Класс Point: Представляет точку на плоскости

Хранит координаты X и Y как числа с плавающей точкой

Имеет методы для сравнения точек по значению координат

Возвращает текстовое представление в формате {X;Y}

Класс Polyline: Представляет ломаную линию

Хранит список точек через которые проходит линия

Возвращает текстовое представление всего пути

Класс Line: Представляет отдельный отрезок линии

Хранит начальную и конечную точки

Возвращает описание отрезка между точками

StreamProcessor: Основной класс обработки

Использует distinct() для удаления точек с одинаковыми координатами

Сортирует точки по X с помощью sorted()

Преобразует отрицательные Y в положительные с помощью map()

Собирает результат в объект Polyline с помощью collect()

Входные и выходные данные

Входные данные: Список точек с координатами X и Y (могут быть отрицательными)

Выходные данные: Объект Polyline содержащий обработанные точки

Процесс обработки:

Удаляются точки с одинаковыми координатами (дубликаты)

Точки сортируются по возрастанию координаты X

У всех точек координата Y становится положительной (модуль числа)

Результат собирается в ломаную линию

Пример: Из точек [ (1,-2), (3,4), (1,-2), (0,5) ] получится ломаная [ (0,5), (1,2), (3,4) ]
